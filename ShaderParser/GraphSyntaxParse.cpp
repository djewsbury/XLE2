// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#pragma warning(disable:4800) // 'int': forcing value to bool 'true' or 'false' (performance warning))

#include "GraphSyntax.h"
#include "ShaderPatcher.h"
#include "ShaderPatcher_Internal.h"
#include "NodeGraphProvider.h"
#include "NodeGraphSignature.h"
#include "AntlrHelper.h"
#include "Grammar/GraphSyntaxLexer.h"
#include "Grammar/GraphSyntaxParser.h"
#include "Grammar/GraphSyntaxEval.h"
#include "../Assets/RawFileAsset.h"
#include "../Assets/Assets.h"
#include "../Utility/FunctionUtils.h"
#include "../Utility/Streams/PathUtils.h"
#include "../ConsoleRig/Log.h"
#include <unordered_map>
#include <stack>

#include <iostream>
#include <sstream>

typedef unsigned NodeId;
typedef unsigned GraphId;
typedef unsigned ConnectorId;
typedef unsigned ConnectionId;
typedef unsigned GraphSignatureId;
typedef unsigned AttributeTableId;

typedef struct IdentifierAndScopeTag
{
	pANTLR3_COMMON_TOKEN _scope;
	pANTLR3_COMMON_TOKEN _identifier;
} IdentifierAndScope;

namespace GraphLanguage
{
	using namespace ShaderSourceParser::AntlrHelper;

	class WorkingGraphSyntaxFile
	{
	public:
		class Graph
		{
		public:
			std::string 		_name;
			NodeGraph 			_graph;
			NodeGraphSignature 	_signature;

			struct Connector { uint32_t nodeId; std::string _name; };
			std::vector<Connector> _connectors;
			std::vector<std::string> _literalConnectors;
			std::unordered_map<std::string, uint32_t> _nodeNameMapping;
		};

		std::vector<NodeGraphSignature> _pendingSignatures;

		std::unordered_map<std::string, std::string> _imports; 
		std::vector<Graph> _graphs;

		std::vector<std::pair<std::string, AttributeTable>> _attributeTables;
	};

	static pANTLR3_BASE_TREE BuildAST(struct GraphSyntaxParser_Ctx_struct& parser)
    {
        ExceptionContext exceptionContext;
        auto result = parser.entrypoint(&parser).tree;
        if (!exceptionContext._exceptions._errors.empty())
            Throw(ShaderSourceParser::Exceptions::ParsingFailure(MakeIteratorRange(exceptionContext._exceptions._errors)));
		return result;
    }

    GraphSyntaxFile ParseGraphSyntax(StringSection<char> sourceCode)
    {
		if (sourceCode.IsEmpty()) Throw(::Exceptions::BasicLabel("Empty string passed to ParseGraphSyntax"));

        AntlrPtr<struct ANTLR3_INPUT_STREAM_struct>	inputStream = antlr3StringStreamNew(
            (ANTLR3_UINT8*)sourceCode.begin(), ANTLR3_ENC_8BIT, 
            (unsigned)sourceCode.size(), (ANTLR3_UINT8*)"InputStream");

        if (!inputStream) Throw(::Exceptions::BasicLabel("Unable to create the input stream due to malloc() failure\n"));
		AntlrPtr<struct GraphSyntaxLexer_Ctx_struct> lxr = GraphSyntaxLexerNew(inputStream);	    // CLexerNew is generated by ANTLR
		if (!lxr) Throw(::Exceptions::BasicLabel("Unable to create the lexer due to malloc() failure\n"));

		AntlrPtr<struct ANTLR3_COMMON_TOKEN_STREAM_struct> tokenStream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
		if (!tokenStream) Throw(::Exceptions::BasicLabel("Out of memory trying to allocate token stream\n"));
		AntlrPtr<struct GraphSyntaxParser_Ctx_struct> psr = GraphSyntaxParserNew(tokenStream);  // CParserNew is generated by ANTLR3
		if (!psr) Throw(::Exceptions::BasicLabel("Out of memory trying to allocate parser\n"));

		auto* ast = BuildAST(*psr);
		if (!ast) Throw(::Exceptions::BasicLabel("Could not build AST from graph syntax input"));

		// StructureDescription(std::cout, ast);

		AntlrPtr<struct ANTLR3_COMMON_TREE_NODE_STREAM_struct> nodes = antlr3CommonTreeNodeStreamNewTree(ast, ANTLR3_SIZE_HINT);
		AntlrPtr<struct GraphSyntaxEval_Ctx_struct> evalTree = GraphSyntaxEvalNew(nodes);

		ExceptionContext exceptionContext;
		WorkingGraphSyntaxFile ng;
		evalTree->_userData = &ng;
		evalTree->entrypoint(evalTree);
		if (!exceptionContext._exceptions._errors.empty())
			Throw(ShaderSourceParser::Exceptions::ParsingFailure(MakeIteratorRange(exceptionContext._exceptions._errors)));
		
		GraphSyntaxFile result;
		result._subGraphs.reserve(ng._graphs.size());
		result._imports = ng._imports;
		for (auto& f:ng._graphs)
			result._subGraphs.emplace(std::make_pair(f._name, GraphSyntaxFile::SubGraph{std::move(f._signature), std::move(f._graph)}));
		for (auto& at:ng._attributeTables)
			result._attributeTables.insert({at.first, std::move(at.second)});
		return result;
    }
	
///////////////////////////////////////////////////////////////////////////////////////////////////

	class GraphNodeGraphProvider : public BasicNodeGraphProvider, public std::enable_shared_from_this<INodeGraphProvider>
    {
    public:
        std::vector<Signature> FindSignatures(StringSection<> name) override;
		std::optional<NodeGraph> FindGraph(StringSection<> name) override;
		std::string TryFindAttachedFile(StringSection<> name) override;

        GraphNodeGraphProvider(
			const std::shared_ptr<GraphSyntaxFile>& parsedGraphFile,
			const ::Assets::DirectorySearchRules& searchRules,
			const ::Assets::DepValPtr& parsedGraphFileDepVal);
        ~GraphNodeGraphProvider();
    protected:
		std::shared_ptr<GraphSyntaxFile> _parsedGraphFile;
		::Assets::DepValPtr _parsedGraphFileDepVal;
    };

	auto GraphNodeGraphProvider::FindSignatures(StringSection<> name) -> std::vector<Signature>
	{
		// todo -- broken functionality
		//			-- previously we could pass in a name without a scoped file. If the name
		//			matched a graph within this graph file, we would just return that directly.
		//			However, this this doesn't work so cleanly now that we're searching for
		//			all of the signatures within a file (as opposed to a single signature at
		//			a time).

		if (!name.IsEmpty()) {
			auto importedName = _parsedGraphFile->_imports.find(name.AsString());
			if (importedName != _parsedGraphFile->_imports.end())
				return BasicNodeGraphProvider::FindSignatures(importedName->second );
			return BasicNodeGraphProvider::FindSignatures(name);
		}

		// Look for all of the functions within the parsed graph syntax file
		std::vector<Signature> result;
		for (const auto&subGraph:_parsedGraphFile->_subGraphs)
			result.push_back(Signature{ subGraph.first, subGraph.second._signature, {}, true, _parsedGraphFileDepVal });

		return result;
	}

	INodeGraphProvider::NodeGraph LoadGraphSyntaxFile(StringSection<> filename, StringSection<> entryPoint)
	{
		auto& asset = ::Assets::GetAsset<::Assets::RawFileAsset>(filename);
		auto inputStr = MakeStringSection((const char*)asset.GetData().begin(), (const char*)asset.GetData().end());

		auto graphSyntax = std::make_shared<GraphLanguage::GraphSyntaxFile>(ParseGraphSyntax(inputStr));
		auto main = graphSyntax->_subGraphs.find(entryPoint.AsString());
		if (main == graphSyntax->_subGraphs.end())
			Throw(::Exceptions::BasicLabel("Couldn't find entry point (%s) in input file (%s)", entryPoint.AsString().c_str(), filename.AsString().c_str()));

		auto sigProvider = MakeGraphSyntaxProvider(graphSyntax, ::Assets::DefaultDirectorySearchRules(filename), asset.GetDependencyValidation());

		return INodeGraphProvider::NodeGraph {
			main->first,
			main->second._graph,
			main->second._signature,
			std::move(sigProvider),
			asset.GetDependencyValidation() };
	}

	auto GraphNodeGraphProvider::FindGraph(StringSection<> name) -> std::optional<NodeGraph>
	{
		// Interpret the given string to find a function signature that matches it
		// First, check to see if it's scoped as an imported function
		auto *scopingOperator = name.begin() + 1;
		while (scopingOperator < name.end()) {
			if (*(scopingOperator-1) == ':' && *scopingOperator == ':')
				break;
			++scopingOperator;
		}
		if (scopingOperator < name.end()) {
			auto import = MakeStringSection(name.begin(), scopingOperator-1).AsString();
			auto functionName = MakeStringSection(scopingOperator+1, name.end());

			auto importedName = _parsedGraphFile->_imports.find(import);
			if (importedName != _parsedGraphFile->_imports.end())
				return BasicNodeGraphProvider::FindGraph(importedName->second + "::" + functionName.AsString());
			return BasicNodeGraphProvider::FindGraph(import + "::" + functionName.AsString());
		}

		// Look for the function within the parsed graph syntax file
		auto i = _parsedGraphFile->_subGraphs.find(name.AsString());
		if (i != _parsedGraphFile->_subGraphs.end())
			return NodeGraph{ i->first, i->second._graph, i->second._signature, shared_from_this(), _parsedGraphFileDepVal };

		return BasicNodeGraphProvider::FindGraph(name);
	}

	std::string GraphNodeGraphProvider::TryFindAttachedFile(StringSection<> name)
	{
		char resolvedName[MaxPath];
		auto splitter = MakeFileNameSplitter(name);
		auto rootName = splitter.DrivePathAndFilename();
		auto importedName = _parsedGraphFile->_imports.find(rootName.AsString());
		if (importedName != _parsedGraphFile->_imports.end()) {
			resolvedName[0] = '\0';
			XlCatString(resolvedName, importedName->second);
			XlCatString(resolvedName, splitter.ExtensionWithPeriod());
			GetDirectorySearchRules().ResolveFile(resolvedName, resolvedName);
		} else {
			GetDirectorySearchRules().ResolveFile(resolvedName, name);
		}
		return resolvedName;
	}

	GraphNodeGraphProvider::GraphNodeGraphProvider(
		const std::shared_ptr<GraphSyntaxFile>& parsedGraphFile,
		const ::Assets::DirectorySearchRules& searchRules,
		const ::Assets::DepValPtr& parsedGraphFileDepVal)
	: BasicNodeGraphProvider(searchRules)
	, _parsedGraphFile(parsedGraphFile)
	, _parsedGraphFileDepVal(parsedGraphFileDepVal)
	{}

	GraphNodeGraphProvider::~GraphNodeGraphProvider()
	{}

	std::shared_ptr<INodeGraphProvider> MakeGraphSyntaxProvider(
		const std::shared_ptr<GraphSyntaxFile>& parsedGraphFile,
		const ::Assets::DirectorySearchRules& searchRules,
		const ::Assets::DepValPtr& dependencyValidation)
	{
		return std::make_shared<GraphNodeGraphProvider>(parsedGraphFile, searchRules, dependencyValidation);
	}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////

	static std::string MakeArchiveName(const IdentifierAndScope& identifierAndScope)
	{
		if (identifierAndScope._scope)
			return ShaderSourceParser::AntlrHelper::AsString<>(identifierAndScope._scope) + "::" + ShaderSourceParser::AntlrHelper::AsString<>(identifierAndScope._identifier);
		return ShaderSourceParser::AntlrHelper::AsString<>(identifierAndScope._identifier);
	}

	WorkingGraphSyntaxFile& GetFileContext(const void* ctx) { return *(WorkingGraphSyntaxFile*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData; }
	WorkingGraphSyntaxFile::Graph& GetGraphContext(const void* ctx, GraphId gid) 
	{
		auto& file = GetFileContext(ctx);
		return file._graphs[gid];
	}

}

extern "C" GraphId Graph_Register(const void* ctx, const char name[], GraphSignatureId signatureId)
{
	auto& f = GraphLanguage::GetFileContext(ctx);

	assert(signatureId < f._pendingSignatures.size());
	const auto& sig = f._pendingSignatures[signatureId];
	
	GraphId nextGraph = (GraphId)f._graphs.size();
	f._graphs.push_back({std::string(name), {}, sig});
	return nextGraph;
}

extern "C" NodeId Node_Register(const void* ctx, GraphId gid, IdentifierAndScope identifierAndScope, const char attributeTableName[])
{
	auto& ng = GraphLanguage::GetGraphContext(ctx, gid);

	NodeId nextId = (NodeId)ng._graph.GetNodes().size();

	auto archiveName = GraphLanguage::MakeArchiveName(identifierAndScope);
	if (identifierAndScope._scope == nullptr) {
		// Check to see if this is a templated parameter. If so, we need to mark the node name with the
		// restrictions from the signature.
		auto i = std::find_if(
			ng._signature.GetTemplateParameters().begin(),
			ng._signature.GetTemplateParameters().end(),
			[archiveName](const GraphLanguage::NodeGraphSignature::TemplateParameter& param) { return param._name == archiveName; });
		if (i != ng._signature.GetTemplateParameters().end()) {
			archiveName += "<" + i->_restriction + ">";
		}
	}

	GraphLanguage::Node newNode{archiveName, nextId, GraphLanguage::Node::Type::Procedure, attributeTableName ? std::string(attributeTableName) : std::string()};
	ng._graph.Add(std::move(newNode));
	return nextId;
}

extern "C" ConnectorId Connector_Register(const void* ctx, GraphId gid, NodeId node, const char connectorName[])
{
	auto& ng = GraphLanguage::GetGraphContext(ctx, gid);
	
	ConnectorId nextId = (ConnectorId)ng._connectors.size();
	ng._connectors.push_back({node, connectorName});
	return nextId;
}

extern "C" ConnectorId LiteralConnector_Register(const void* ctx, GraphId gid, const char literal[])
{
	auto& ng = GraphLanguage::GetGraphContext(ctx, gid);
	
	ConnectorId nextId = 0xf0000000u | (ConnectorId)ng._literalConnectors.size();
	ng._literalConnectors.push_back(literal);
	return nextId;
}

extern "C" ConnectorId IdentifierConnector_Register(const void* ctx, GraphId gid, IdentifierAndScope identifierAndScope)
{
	auto& ng = GraphLanguage::GetGraphContext(ctx, gid);

	ConnectorId nextId = 0xf0000000u | (ConnectorId)ng._literalConnectors.size();
	ng._literalConnectors.push_back(GraphLanguage::MakeArchiveName(identifierAndScope));
	return nextId;
}

extern "C" ConnectorId PartialInstantiationConnector_Register(const void* ctx, GraphId gid, NodeId node)
{
	auto& ng = GraphLanguage::GetGraphContext(ctx, gid);

	ConnectorId nextId = (ConnectorId)ng._connectors.size();
	ng._connectors.push_back({node, GraphLanguage::ParameterName_NodeInstantiation});
	return nextId;
}

extern "C" ConnectionId Connection_Register(const void* ctx, GraphId gid, ConnectorId left, ConnectorId right)
{
	auto& ng = GraphLanguage::GetGraphContext(ctx, gid);
	
	if (left >= ng._connectors.size())
		return ~0u;

	if (right & 0xf0000000u) {
		if ((right & ~0xf0000000u) >= ng._literalConnectors.size())
			return ~0u;

		ng._graph.Add({
			GraphLanguage::NodeId_Constant, ng._literalConnectors[right & ~0xf0000000u],
			ng._connectors[left].nodeId, ng._connectors[left]._name});
		return (ConnectionId)ng._graph.GetConnections().size()-1;
	} else {
		if (right >= ng._connectors.size())
			return ~0u;

		ng._graph.Add({
			ng._connectors[right].nodeId, ng._connectors[right]._name,
			ng._connectors[left].nodeId, ng._connectors[left]._name});
		return (ConnectionId)ng._graph.GetConnections().size()-1;
	}
}

extern "C" void Connection_SetCondition(const void* ctx, GraphId gid, ConnectionId connection, const char condition[])
{
	auto& ng = GraphLanguage::GetGraphContext(ctx, gid);

	if (connection >= ng._graph.GetConnections().size())
		return;

	ng._graph.GetConnections()[connection]._condition = condition;
}

extern "C" void Node_Name(const void* ctx, GraphId gid, NodeId id, const char name[])
{
	auto& ng = GraphLanguage::GetGraphContext(ctx, gid);
	ng._nodeNameMapping.insert({name, id});
}

extern "C" NodeId Node_Find(const void* ctx, GraphId gid, const char name[])
{
	auto& ng = GraphLanguage::GetGraphContext(ctx, gid);
	std::string n(name);
	auto i = ng._nodeNameMapping.find(n);
	if (i != ng._nodeNameMapping.end()) return i->second;
	return ~0u;
}

extern "C" GraphSignatureId GraphSignature_Register(const void* ctx)
{
	auto& f = GraphLanguage::GetFileContext(ctx);
	auto nextId = (unsigned)f._pendingSignatures.size();
	f._pendingSignatures.push_back({});
	return nextId;
}

extern "C" void GraphSignature_ReturnType(const void* ctx, GraphSignatureId sigId, const char returnType[])
{
	auto& f = GraphLanguage::GetFileContext(ctx);
	f._pendingSignatures[sigId].AddParameter({returnType, GraphLanguage::s_resultName, GraphLanguage::ParameterDirection::Out});
}

extern "C" void GraphSignature_AddParameter(const void* ctx, GraphSignatureId sigId, const char name[], const char type[], unsigned direction, const char def[])
{
	auto& f = GraphLanguage::GetFileContext(ctx);
	f._pendingSignatures[sigId].AddParameter({type, name, GraphLanguage::ParameterDirection(direction), std::string(), def ? def : std::string()});
}

extern "C" void GraphSignature_AddGraphParameter(const void* ctx, GraphSignatureId sigId, const char name[], IdentifierAndScope prototype)
{
	auto& f = GraphLanguage::GetFileContext(ctx);
	f._pendingSignatures[sigId].AddTemplateParameter({name, GraphLanguage::MakeArchiveName(prototype)});
}

extern "C" void GraphSignature_Implements(const void* ctx, GraphSignatureId sigId, IdentifierAndScope templ)
{
	auto& f = GraphLanguage::GetFileContext(ctx);
	assert(templ._scope && templ._identifier);
	f._pendingSignatures[sigId].SetImplements(GraphLanguage::MakeArchiveName(templ));
}

extern "C" void Import_Register(const void* ctx, const char alias[], const char import[])
{
	auto& f = GraphLanguage::GetFileContext(ctx);
	assert(f._imports.find(alias) == f._imports.end());
	f._imports.insert(std::make_pair(alias, import));
}

extern "C" void Captures_Register(const void* ctx, GraphId gid, const char name[], GraphSignatureId params, const char attributeTableName[])
{
	auto& ng = GraphLanguage::GetGraphContext(ctx, gid);
	auto& f = GraphLanguage::GetFileContext(ctx);
	auto& sig = f._pendingSignatures[params];

	// We construct 2 things: one is a node to represent these collection of parameters
	// We must also add the parameters to the "captures" list in the graph signature
	NodeId nextId = (NodeId)ng._graph.GetNodes().size();
	ng._graph.Add(GraphLanguage::Node { name, nextId, GraphLanguage::Node::Type::Captures, attributeTableName ? std::string(attributeTableName) : std::string() });
	Node_Name(ctx, gid, nextId, name);

	for (const auto& i:sig.GetParameters()) {
		auto newParam = i;
		newParam._name = std::string(name) + "." + i._name;
		newParam._direction = GraphLanguage::ParameterDirection::In;
		ng._signature.AddCapturedParameter(newParam);
	}
}

extern "C" AttributeTableId AttributeTable_Register(const void* ctx, const char name[])
{
	auto& f = GraphLanguage::GetFileContext(ctx);
	auto existing = std::find_if(f._attributeTables.begin(), f._attributeTables.end(),
		[name](std::pair<std::string, GraphLanguage::AttributeTable>& t) { return t.first == name; });
	assert(existing == f._attributeTables.end());

	f._attributeTables.push_back({name, {}});
	return AttributeTableId(f._attributeTables.size()-1);
}

extern "C" void AttributeTable_AddValue(const void* ctx, AttributeTableId tableId, const char key[], const char value[])
{
	auto& f = GraphLanguage::GetFileContext(ctx);
	assert(tableId < f._attributeTables.size());
	f._attributeTables[tableId].second[key] = value;
}
